
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE!
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  \usepackage{epstopdf}
  % declare the path(s) where your graphic files are
  \graphicspath{{E:/Documents/Iowa_State/2013-2014/COMS583/Proposal/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )
% correct bad hyphenation here

\usepackage{tikz}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Break Out: Implementing Old School Games on FPGAs}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Brian Nakayama}
\IEEEauthorblockA{Department of Computer Science\\
Iowa State University\\
Ames, Iowa 50011}
\and
\IEEEauthorblockN{Mahieddine Dellabani}
\IEEEauthorblockA{Ensimag, School of Computer Engineering\\
Grenoble INP\\
Grenoble, France}}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
%
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3},
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}
%\boldmath
The following follows up Implementing \emph{Breakout} on an FPGA.
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
FPGA's have great potential for instructing young computer scientists and engineers on the basics of digital design. Many classes focus on implementing a computer in an FPGA; however, implementing a game can drive students to increase the complexity and time spent on their projects, as shown by increased software support in students that focus on the creation of games instead of a different project \cite{Brunvand:2011}.

For education outside of the classroom, in people's basements, in less developed countries, and in the Do-It-Yourself communities FPGA's are creating interest for their video processing capabilities, as a more powerful solution over the average microcontroller. Companies such as AdaFruit now sell FPGA's geared towards the hobbyist for a relatively low price of 80USD \cite{Ada:2013}. For many the hardware is available, but the knowledge to use it is a little too much for one's wallet. For people who wish to add FPGA's to their projects and for people just beginning their journey, the benefit of free, fun, and intelligible tutorials are indispensable. Using the classic game, \emph{Breakout} \cite{Goldberg:2009}, we propose to document the process of making the game while implementing it on the Xilinx Virtex 5.\\

The choice of \emph{Breakout} comes from its historical implementation in exclusively digital hardware (no processor)\cite{Goldberg:2009}, and its strong following. Similar to modern video-games, \emph{Breakout} would command weeks on attention: ``It had looked like there was no more of a skill to Breakout than a skill at getting thirsty" \cite{david:1984}. The novel human-mechanical interaction created by \emph{Breakout} has even inspired a book over 150 pages in length, which feels like quite the feat for a game that is rather simple. The rich history of \emph{Breakout} sets it apart from other game choices.

\section{Related Work}

\subsection{Previous Break Out Implementation}
While researching the requirements for implementing \emph{Breakout}, we found a previously developed project implemented by Doug Crumbie\cite{Cumbie:2008}. The approach by Crumbie differs slightly in its use of an authentic Atari controller, as opposed to our planned implementation which will require only a keyboard. Also, his implementation uses Verilog whereas we will be using VHDL. Finally, our projects will differ in how we organize our logic, as we will focus on an implementation that looks more like a pipeline (see Figure~\ref{}), as opposed to the design flow Crumbie implemented which requires high coupling between components.

Furthermore, in the game focused curriculum created by Brunvard \cite{Brunvand:2011}, he reported that some of his students implemented \emph{Breakout} as their final project.

No other implementations of \emph{Breakout} were found; however, the previous implementations do present a challenge. What can our project do that other projects have not already done? In preparing for this project, we hope to create more modular logic libraries that may suit a wider set of purposes than the ones created by Crumbie\cite{Cumbie:2008}. In the spirit of Brunvard's curriculum \cite{Brunvand:2011} we will implement our design in a well documented, intelligible way to serve as a tutorial for others.

\subsection{Breakout}
No formal specification for \emph{Breakout} was found. Thus we will describe \emph{Breakout} using the following general specifications:

\begin{enumerate}
  \item The player controls a paddle that can move left and right.
  \item A ball (square pixel) bounces off the paddle based off the coordinate of collision with the paddle (and not based on the angle of incidence).
  \item The ball then can collide with walls, inverting its horizontal velocity, or with bricks inverting its vertical velocity.
  \item The ball destroys bricks upon collision.
  \item The player is penalized if the ball falls below the screen without hitting the paddle.
\end{enumerate}

Depending on time, other specifications may be added, such as ``power-ups" for the paddle or ball. Figure~\ref{Breakout} shows a snapshot of the game, with annotations for our project.

\begin{figure}[!t]
\centering
\includegraphics[width=3in]{Breakout2600}
\caption{The (annotated) Breakout Game.}
\label{Breakout}
\end{figure}

\subsection{Video Gate Array}
Our implementation for \emph{Breakout} will use the VGA output provided on the Xilinx Virtex 5 board. Documentation for how to access the pins in VHDL code can be found in the documentation for the board \cite{Xilinx:2011}.

The physical connector for VGA output and input is well documented \cite{Honza:2013}. Only 5 pins carry the necessary output to the monitor, pins $1-3$ for the red, blue, and green data and pins $13-14$ for the horizontal and vertical sync. Other pins allow the monitor and the controller communicate configuration settings depending on the standard used. For this project, a standard $640 \times 480$ resolution will be assumed.

For the timing of the VGA monitor, we expect a clock frequency of $25.175$ MHz to generate a frame every $16.68$ ms or at a frequency of $~60$Hz \cite{Stessen:1997}. The timing for the horizontal pixels of the vertical lines looks fairly similar. For the horizontal pixels ($31.77 \mu$s) there's a synchronizing pulse for $3.77 \mu$s followed by a back porch of $1.89\mu$s, the active video time of $25.17\mu$, and a front porch of $0.94\mu$s. The vertical timing works similarly using lines instead of pixels (rastering one line at a time). Figure~\ref{vga} shows the pin connections and a timing diagram.

\begin{figure*}[!t]
\centering
\includegraphics[width=7in]{VGADiagram}
\caption{Video Graphics Array Specifications: (A) Pin Diagram. (B) Horizontal Timing Diagram. (C) Vertical Timing Diagram.}
\label{vga}
\end{figure*}

\subsection{Keyboard}
In order to communicate with our game, we have elected to use a keyboard through the PS/2 controller instead of an Atari controller.


\begin{figure}[!t]
\centering
\includegraphics[width=3in]{FSM}
\caption{Example Finite State Machines.}
\label{FSM}
\end{figure}
The PS/2 Keyboard uses serial communication to talk to a PS/2 controller. As we can see in the Figure~\ref{keyboard}(C), a PS/2 connection port has 6 pins. The Data pin (pin 1) and the clock pin (pin 5) are the most relevant for the implementation of the PS/2 communication protocol \cite{Chapweske:2003}.

For communication the PS/2 enables a bidirectional serial communication host-to-device and device-to-host. The host has total control over the bus (in our case the host is the FPGA board and the device is the keyboard) and may inhibit communication at any time by pulling the clock line low \cite{Chapweske:2003}.

The bus has the following states for communicating bidirectionally\cite{Chapweske:2003}:
\begin{enumerate}
\item Idle state : data = high, clock = high
\item Inhibited Communication state : data = high, clock = low
\item Host Request to Send state: data = low, clock = high
\end{enumerate}

The communication’s protocol consists of sending and receiving frames. Each frame includes\cite{Chapweske:2003}:
\begin{itemize}
\item 1 start bit (this bit is always zero)
\item 1 data byte (the least significant bit first)
\item 1 parity bit (odd parity)
\item 1 stop bit (this bit is always one)
\item 1 acknowledge bit (host to device communication only)
\end{itemize}

Each frame is sent bit-by-bit through the PS/2 Data-pin (see Figure~\ref{keyboard}).

The parity bit is set if there is an even number of 1’s in the data byte and reset if this number is odd. Thus, the sum of the parity bit and the number of 1’s in the data byte is always an odd number. Since the probability of more than one bit changing during communication is extremely low, this error detection strategy lets us ask the keyboard to send a correct data byte if the sum of the bits in the byte with the parity bit is even \cite{Chapweske:2003}.

As mentioned earlier, the host has complete control of the bus. So if the keyboard has data to send, it will check first if the clock is high.  The Clock line must be continuously high for at least $50$ microseconds before the device can begin to transmit it's data. The Keyboard writes the data on the bus when the clock is high, and the host reads the data when the clock is low.

For host-to-device communication, the way of proceeding is slightly different from device-to-host communication. As the device which generates the clock signal, in order to send data the host also has to pull the bus to the ``Request-to send” state as follows:

\begin{enumerate}
\item Inhibit communication by pulling the Clock low for at least $100$ microseconds.
\item Apply ``Request-to-send" by pulling Data low, then release Clock.
\end{enumerate}

When the device detects this request (state of the bus), it will begin generating a clock signal for $9$ cycles ($8$ cycles for the data and $1$ cycle for the stop bit). After the stop bit is received, the device will acknowledge the received byte by bringing the data line low and generating one last clock pulse\cite{Howie:2009}.

\begin{figure*}[!t]
\centering
\includegraphics[width=5in]{Keyboard}
\caption{Timing Diagram for Keyboard: (A) Device to Host. (B) Host to Device. (C) Pin Diagram.}
\label{keyboard}
\end{figure*}

\section{Proposed Approach}
\subsection{Design Specifications}
%-- TODO: Put Some diagrams and figures
		
The breakout project deals with two external elements: a keyboard and a monitor. The keyboard and the monitor controls will be implemented in separate blocks. Also, considering the implementation of the game and the production of the output images, the systems needs three more blocks: a controller block, a logic\_game block and a process\_image block. Figure~\ref{block} below gives a global overview of our hardware system. The blocks function as follows:
\begin{itemize}
\item Keyboard
\begin{itemize}
\item This block implements the communication protocol between a PS/2 keyboard and our system through a PS/2 port. This block has 2 paths: a control path and a data path. Using sub-components like timers, fifo buffer, flip-flops and shift registers will process the input bit-stream and build the scan code byte for each key pressed.
\item Input: PS/2 data stream and PS/2 clock, Output: key code.
\end{itemize}
\item Controller
\begin{itemize}
\item This block receives the user’s input from the keyboard block, processes it and sends control signals to the game block.
\item Input: key code, Output: control signals (i.e. \emph{left, right, pause, ...})
\end{itemize}
\item Game
\begin{itemize}
\item This block implements the game’s logic. It keeps a state for the current frame of the game, and it computes the next state of the game using the control signals received from the controller.
\item Input: control signals, Output: state of the game (i.e. \emph{paddle coordinate, ball coordinates, brick array, score, paused, ...})
\end{itemize}
\item Process\_Image
\begin{itemize}
\item The image block updates the image to be displayed on the monitor.
\item Input: state of the game, Output: $640\times 480 \times 16$ bit image.
\end{itemize}
\item VGA
\begin{itemize}
\item Converts an image into the signals out to the VGA pins.
\item Input: bit image, Output: VGA signals (i.e. \emph{Red, Green, Blue, Vsync and Hsync}).
\end{itemize}
\item RAM
\begin{itemize}
\item Some RAM blocks may be used for storing image data.
\item Input: $640\times 480 \times 16$ bit images, Output: $640\times 480 \times 16$ bit images.
\end{itemize}
\end{itemize}

\begin{figure*}[!t]
\centering
\includegraphics[width=7in]{Project}
\caption{Block Diagram for Breakout Implementation. }
\label{block}
\end{figure*}

We anticipate that the logic inside of the \emph{Breakout} game should not add too much complexity when compared to the VGA and Keyboard interfaces. Each component in the game shown in Figure~\ref{Breakout} will have it's own FSM with the exception of perhaps the walls, which will remain constant throughout the game. Our general implementation for the game components follows:
\begin{itemize}
\item The Ball
\begin{itemize}
\item The ball moves in two dimensions, colliding with bricks, the paddle and other things. For this implementation, it will be assumed that the paddle affects the state of the ball, the bricks also affect the state of the ball, the ball affects the state of the bricks, and the ball affects the state of the game. By creating directed links of which components affect other components, we can create our finite state machines, and the architectures of our components with ease.
\item Input: collision signal(from bricks), collision signal and direction signal(from paddle), global game signals. Output: x,y coor.(to bricks and to paddle), y coordinate(to global game).
\end{itemize}
\item The Paddle
\begin{itemize}
\item The paddle moves in one dimension. All it really needs to is move left and right and collide with the ball. Depending on where the ball collides with the paddle affects the angle of the balls bounce.
\item Input: direction signals(from global game), x,y coor.(from ball), global game signals. Output: collision signal and direction signal(to ball).
\end{itemize}
\item The Bricks
\begin{itemize}
\item The bricks will be stored as an array of 1's and 0's. A 1 represents the existence of a brick at a particular position. A 0 represents the absence of a brick. The colors of the bricks will be implemented by the Process\_Image module(not included in this list). Other global game signals will reset or otherwise manipulate the position of the bricks.
\item Input: x,y coor.(from ball), global game signals. Output: collision signal (to ball), state(to global game).
\end{itemize}
\end{itemize}

The elaboration of the three components examined does not include interactions with the score, the Process\_Image module, or all of the global game signals. It does however, represent the ``bread and butter" of the \emph{Breakout} game. Figure~\ref{FSM} shows some example FSMs designed for illustration (we may not implement those FSMs exactly).

\subsection{Methodologies}
Implementation of the \emph{Breakout} game will follow a step-by-step modular approach with emphasis on testing at each stage. Testing can be done using Modelsim with the creation of appropriate test cases. For some of the higher-level modules, tests may be carried out using the VGA Core to output images. As long as the VGA core is working properly this method should work better for testing game hardware as the number of interacting objects may make it hard to test in Modelsim. (For example it may be difficult to generate test code that moves the paddle in anticipation for the ball.)

The high level of modularity, with clearly defined inputs and outputs, makes it easier to assign modules of work to different developers. For example, the keyboard core and the VGA core can be developed in parallel at the same time. Likewise, we can also implement different parts of the game at the same time, hooking the wires controlling their movements towards the end. Many of the pieces of the game represent simple finite state machines that work independently of each other. This separation of the work will help increase productivity, until the final steps where we must hook the different components together.

This project includes some optional goals such as implementing sound or extending the game (for example, we might implement powerups or cool graphical effects).

We will follow the following spiral/agile implementation cycle :
\begin{enumerate}
\item Implementation of the Keyboard Core.
\item Test and debug of Keyboard Core, testing the necessary keys on Modelsim.
\item Test of Keyboard Core using LEDs on Xilinx Board.
\item Implementation of the VGA Core.
\item Test and debug of VGA Core, testing the signal times on Modelsim.
\item Test VGA on monitor to print a simple square or image in RAM.
\item Implementation of Process\_Image module.
\item Test Process\_Image module using VGA core.
\item Implementation of Game.
\begin{enumerate}
\item Implementation of paddle.
\item Connect paddle movements to outputs of Keyboard Core, and to inputs of Process\_Image module.
\item Test on modelsim and then using VGA.
\item Implementation of ball, bricks, and walls.
\item Hook components together.
\item Test valid interactions using VGA.
\item Implement Score Keeping.
\item Generate Text output for the Process\_Image module, and feed score to inputs.
\item Test using VGA.
\item Optional: Implement Sound (if time allows).
\end{enumerate}
\item Optional: Implement other games or other features for \emph{Breakout}
\item Prepare presentation/Demo.
\end{enumerate}

Each subitem shall be part of the documentation process. The documentation process deserves some elaboration.

The main goals of this project are 1. To implement \emph{Breakout} successfully, and 2. To create a tutorial that effectively guides students through the design of a game on an FPGA. Thus our documentation aims to be intelligible and it should also explain those finer details that can cost a student hours of trouble shooting. With an emphasis on \emph{fun}, we essentially hope to make clear and concise modules that are easy to follow along; however, we must also insert a caveat. As both members of our team have very little experience in educating others, writing lesson plans, or making tutorials of any kind, there exists a chance that we are underestimating this part of our project. Hopefully this is not the case. At the present moment, we lack ways to measure the quality of such documentation (measures akin to can an 11th grader follow these instructions?).

\section{Conclusion}

Implementing \emph{Breakout} on the Xilinx Virtex 5 is feasible for both the hardware resources and the time allotted towards development. The project has value as an educational tool, as the process will be documented for other educators/DIY enthusiasts. The demo will hopefully provide some entertainment on what might otherwise be a stressful day for most. We look forward to working on this project.

\bibliographystyle{IEEEtran}
\bibliography{E:/Documents/Iowa_State/2013-2014/COMS583/Proposal}{}



\end{document}


keyboard
A-inputs: PS2D, PS2C and outputs:scan_ready, scan_code

For the communication between the keyboard and the FPGA board,
the keyboard module (Kbd.vhd) implements a Device to host communication.
Data sent from the keyboard has a 11-bits format: a start bit, 7 bits of data,
a parity bit and a stop bit.

The start and stop bits are always equal to 0 and 1 respectively and the parity bit
corresponds to an odd parity. It means that it is set if there is an even number of one's
in the data bits otherwise it is cleared. This is used for errors checking, so when an 
error occures the bit packet is withdrawn.

The 8 bits data correspond to either the scancode of the key pressed, the
key up code (``F0'') or the extend scancode for the extrended keys (``E0''). (see more about it
in the controller section)

The keyboard writes the data bit per bit on the data line (PS2D) when clock(PS2C) is high, 
so they can be read by the host when the clock is low.

During the sampling, the 8 bits data are gathered into a 1-byte vector using
the following shifting operation: 

1-  scan_code_reg (6 downto 0) <= scan_code_reg (7 downto 1);  
2-  scan_code_reg (7)          <= keyboard_data;

The new incoming keyboard_data bit is always received in the 7th index after shifting the previous bits
to the right.
  
when data are ready, the signal scan_ready is set to one for one clock cycle notifying thus 
the controller. Figure n°? (b) shows how the scan_ready is either set or cleared.   

Figure n°? (a) displays a high level view of the device to host communication.


controller
inputs: scan_ready scan_code outputs: control_en, control_mode, control_signal

The keyboard uses scan codes to communicate the key pressed data. Each key has a particular 
scan code (1 byte). If a key is pressed, its scan code is sent and if it's held down, the scan
code will be sent repeatedly once every 100ms(refer to DATAsheet). When released, the keyboard
send the key-up code (``F0'') followed by the scan code of the realesed key.

However there are special keys in the kyeboard, where the byte ``E0'' is sent first ahead of the scan
code and when pressed repeatidly the bytes ``E0'' + teh corresponding scan code are sent.
The key-up bytes for those keys are ``E0 F0''.

The controller take in consideration the following keys :
ESC : is used to End the game
space: is used to pause the game
enter: is used to launch the game
the arrows (special keys) : are used to control the paddle

The controller is implemented in a final state machine style (figure ?).
It separates the received scan codes into two categories:

1-control codes : they represent the arrows' scan code, so when received 
the variable control_en will be set and the control_signal will have one of the 
following values:
go_left : when the left arrow is pressed
go_right : when the right arrow is pressed

2- mode codes : they refere to the control keys (space, launch, entern esc).
When received the signal control_mode is set and the control signal will have 
on of the following values:
end : when esc is pressed
pause : when space is pressed
launch : when enter is pressed

The implementation was spread into these two categories for a matter of use and in 
order to have a smoother move of the paddle.
